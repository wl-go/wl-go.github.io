<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wl-go.github.io</id>
    <title>wlgo 博客</title>
    <updated>2021-01-08T07:32:15.975Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wl-go.github.io"/>
    <link rel="self" href="https://wl-go.github.io/atom.xml"/>
    <subtitle>记录学习中的点点滴滴！</subtitle>
    <logo>https://wl-go.github.io/images/avatar.png</logo>
    <icon>https://wl-go.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, wlgo 博客</rights>
    <entry>
        <title type="html"><![CDATA[Intent]]></title>
        <id>https://wl-go.github.io/post/intent/</id>
        <link href="https://wl-go.github.io/post/intent/">
        </link>
        <updated>2021-01-08T02:18:55.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="#intent-%E7%AE%80%E4%BB%8B">Intent 简介</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA-intent">创建 Intent</a>
<ul>
<li><a href="#%E7%BB%84%E4%BB%B6%E5%90%8D%E7%A7%B0">组件名称</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C-action">操作 action</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE-data">数据 data</a></li>
<li><a href="#%E7%B1%BB%E5%88%AB-category">类别 category</a></li>
<li><a href="#%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF-extra">附加信息 extra</a></li>
<li><a href="#%E6%A0%87%E5%BF%97-flag">标志 flag</a></li>
</ul>
</li>
<li><a href="#%E6%8E%A5%E6%94%B6%E9%9A%90%E5%BC%8Fintent">接收隐式Intent</a></li>
<li><a href="#%E5%BE%85%E5%AE%9A-pendingintent">待定 PendingIntent</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81intent">常见Intent</a></li>
</ul>
<h1 id="intent-简介">Intent 简介</h1>
<p>Intent 作为<code>消息传递对象</code>，可作为<code>组件之间的通信</code>，其分为<code>显示</code>、<code>隐式</code>类型</p>
<ul>
<li>显示：通过提供目标应用的软件包名称或完全限定的组件类名来指定可处理 Intent 的应用</li>
<li>隐式：不会指定特定的组件，而是声明要执行的常规操作<code>Action</code>，从而允许其他应用中的组件来处理</li>
</ul>
<p>基本用法：</p>
<ol>
<li>启动Activity</li>
<li>启动服务</li>
<li>传递广播</li>
</ol>
<h1 id="创建-intent">创建 Intent</h1>
<blockquote>
<p>Intent 主要包含一下这些内容：<code>组件名称</code>、<code>action</code>、<code>data</code>、<code>category</code>、<code>extra</code>、<code>flag</code></p>
</blockquote>
<h2 id="组件名称">组件名称</h2>
<blockquote>
<p>要启动的组件名称，构建<code>显式 Intent</code> 的一项重要信息，这意味着 Intent 应当仅传递给由组件名称定义的应用组件。**如果没有组件名称，则 Intent 则为隐式，**且系统将根据其他 Intent 信息（例如，以下所述的操作、数据和类别）决定哪个组件应当接收 Intent。</p>
<p>Intent 的这一字段是 ComponentName 对象，可以使用目标组件的<code>完全限定类名指定此对象</code>，其中包括应用的软件包名称，可以使用 <code>setComponent()</code>、<code>setClass()</code>、<code>setClassName()</code>，或 Intent 构造函数设置组件名称</p>
</blockquote>
<h2 id="操作-action">操作 action</h2>
<blockquote>
<p>指定要执行的通用操作的字符串<br>
指定自己的操作，供 Intent 在应用内使用（或者供其他应用在您的应用中调用组件）。但是，通常应该使用由Intent 类或其他框架类定义的<code>操作常量</code><br>
有关更多定义通用操作的常量，请参阅 Intent 类参考文档，<a href="https://developer.android.google.cn/reference/android/content/Intent#standard-activity-actions">Intent</a> ，<a href="https://developer.android.google.cn/reference/android/provider/Settings#ACTION_ACCESSIBILITY_SETTINGS">Settings 操作常量</a></p>
<p>可以使用 <code>setAction()</code> 或 Intent <code>构造函数</code>为 Intent 指定操作、<code>&lt;action&gt;</code></p>
<p><strong>如果定义自己的操作，请确保加入应用的软件包名称作为前缀</strong></p>
</blockquote>
<h2 id="数据-data">数据 data</h2>
<blockquote>
<p>引用待操作数据和/或该数据 MIME 类型的 <code>URI</code>（Uri 对象）。提供的数据类型通常由 Intent 的操作决定<br>
创建 Intent 时，除了指定 URI 以外，指定<code>数据类型</code>（其 MIME 类型）往往也很重要。例如，能够显示图像的 Activity 可能无法播放音频文件，即便 URI 格式十分类似时也是如此。因此，指定数据的 MIME 类型有助于 Android 系统找到接收 Intent 的最佳组件</p>
<p>要<code>仅设置数据 URI</code>，请调用 <code>setData()</code>。要<code>仅设置 MIME 类型</code>，请调用 <code>setType()</code>，如有必要，可以使用 <code>setDataAndType()</code>同时显式设置二者。</p>
<p><strong><code>注意</code></strong>：若要<code>同时设置 URI 和 MIME 类型</code>，<code>请勿</code>调用 setData() 和 setType()，因为它们会互相抵消彼此的值。请<code>始终使用 setDataAndType() 同时设置 URI 和 MIME 类型</code><br>
<code>&lt;data&gt;</code></p>
</blockquote>
<h2 id="类别-category">类别 category</h2>
<blockquote>
<p>一个包含应处理 Intent 组件类型的附加信息的字符串，<code>可以将任意数量的类别描述</code>放入一个 Intent 中，以下是一些常见类别：<a href="https://developer.android.google.cn/reference/android/content/Intent#standard-categories">常见类别</a></p>
<p>可以使用 <code>addCategory()</code> 指定类别、<code>&lt;category&gt;</code></p>
</blockquote>
<h2 id="附加信息-extra">附加信息 extra</h2>
<blockquote>
<p>携带完成请求操作所需的<code>附加信息的键值对</code>，正如某些操作使用特定类型的数据 URI 一样，有些操作也使用特定的 extra<br>
可以使用各种 <code>putExtra()</code> 方法添加 extra 数据，每种方法均接受两个参数：键名和值，还可以创建一个包含所有 extra 数据的 <code>Bundle 对象</code>，然后使用 <code>putExtras()</code>将 Bundle 插入 Intent 中</p>
<p><a href="https://developer.android.google.cn/reference/android/content/Intent#standard-extra-data">Intent 类将为标准化的数据类型指定多个 EXTRA_* 常量</a></p>
<p>如需声明自己的 extra 键（对于应用接收的 Intent），<code>请确保将应用的软件包名称作为前缀</code></p>
<p><code>注意：</code>在发送希望另一个应用接收的 Intent 时，请勿使用 <code>Parcelable</code> 或 <code>Serializable</code> 数据。如果某个应用尝试访问 Bundle 对象中的数据，但没有对打包或序列化类的访问权限，则系统将提出一个 RuntimeException。</p>
</blockquote>
<h2 id="标志-flag">标志 flag</h2>
<blockquote>
<p><code>标志</code>在 Intent 类中定义，充当 Intent 的<code>元数据</code>。标志可以<code>指示 Android 系统如何启动 Activity（例如，Activity 应属于哪个任务），以及启动之后如何处理</code>（例如，Activity 是否属于最近的 Activity 列表）<br>
<code>setFlags()</code>，<a href="https://developer.android.google.cn/reference/android/content/Intent#setFlags(int)">flag文档</a></p>
</blockquote>
<h1 id="接收隐式intent">接收隐式Intent</h1>
<blockquote>
<p>要接收哪些<code>隐式 Intent</code>，在清单文件中使用 <code>&lt;intent-filter&gt;</code> 元素为每个应用组件声明<code>一个或多个 Intent 过滤器</code>。每个 Intent 过滤器均根据 Intent 的<code>操作</code>、<code>数据</code>和<code>类别</code>指定自身接受的 Intent 类型。仅当隐式 Intent 可以通过 Intent 过滤器之一传递时，系统才会将该 Intent 传递给应用组件。<br>
应用组件应当为自身可执行的<code>每个独特作业声明单独的过滤器</code>。例如，图像库应用中的一个 Activity 可能会有两个过滤器，分别用于查看图像和编辑图像。当 Activity 启动时，将检查 Intent 并根据 Intent 中的信息决定具体的行为（例如，是否显示编辑器控件）。</p>
<p>每个 Intent 过滤器均由应用清单文件中的 <code>&lt;intent-filter&gt;</code> 元素定义，并嵌套在相应的应用组件（例如，<activity> 元素）中。在<code>&lt;intent-filter&gt; 内部</code>，可以使用以下三个元素中的<code>一个或多个</code>指定要接受的 Intent 类型：</p>
<p><code>&lt;action&gt;</code> 在 name 属性中，声明接受的 Intent 操作。该值必须是操作的文本字符串值，而不是类常量。<br>
<code>&lt;data&gt;</code> 使用<code>一个或多个</code>指定<code>数据 URI</code>（scheme、host、port、path）各个方面和 <code>MIME 类型的属性</code>，声明接受的数据类型。<br>
<code>&lt;category&gt;</code> 在 name 属性中，声明接受的 Intent 类别。该值必须是操作的文本字符串值，而不是类常量。</p>
<p><code>注意：</code>要接收隐式 Intent，必须将 <code>CATEGORY_DEFAULT 类别</code>包括在 Intent 过滤器中。方法 startActivity() 和 startActivityForResult() 将按照其声明 CATEGORY_DEFAULT 类别的方式处理所有 Intent。如果未在 Intent 过滤器中声明此类别，则隐式 Intent 不会解析为您的 Activity。</p>
<p>可以创建一个包括多个 <action>、<data> 或 <category> 实例的过滤器。创建时，需确定组件能够处理这些过滤器元素的任何及所有组合。</p>
<p>系统通过将 Intent 与所有这三个元素<code>进行比较</code>，根据过滤器测试隐式 Intent。隐式 Intent 若要传递给组件，<code>必须通过所有这三项测试</code>。如果 Intent 甚至无法匹配其中任何一项测试，则 Android 系统不会将其传递给组件。但是，由于一个组件可能有多个 Intent 过滤器，因此未能通过某一组件过滤器的 Intent 可能会通过另一过滤器。</p>
<p><code>注意：</code> 使用 Intent 过滤器时，无法安全地防止其他应用启动组件。尽管 Intent 过滤器将组件限制为仅响应特定类型的隐式 Intent，但如果开发者确定您的组件名称，则其他应用有可能通过使用显式 Intent 启动您的应用组件。如果必须确保只有您自己的应用才能启动您的某一组件，请勿在您的清单中声明 Intent 过滤器。而是将<code>该组件的 exported 属性设置为 &quot;false&quot;。</code></p>
</blockquote>
<h1 id="待定-pendingintent">待定 PendingIntent</h1>
<blockquote>
<p>PendingIntent 对象是 Intent 对象的包装器。PendingIntent 的主要目的是授权外部应用使用包含的 Intent，就像是它从您应用本身的进程中执行的一样。</p>
<p>待定 Intent 的主要用例包括：</p>
<ol>
<li>声明用户使用通知执行操作时所要执行的 Intent（Android 系统的 NotificationManager 执行 Intent）。</li>
<li>声明用户使用应用微件执行操作时要执行的 Intent（主屏幕应用执行 Intent）。</li>
<li>声明未来某一特定时间要执行的 Intent（Android 系统的 <code>AlarmManager 执行 Intent</code>）</li>
</ol>
<p>由于每个 Intent 对象均设计为由特定类型的应用组件进行处理（Activity、Service 或 BroadcastReceiver），因此还必须基于相同的考虑因素创建 PendingIntent。使用待定 Intent 时，应用不会使用调用（如 startActivity()）执行该 Intent。相反，通过调用相应的创建器方法创建 PendingIntent 时，必须声明所需的<code>组件类型：</code></p>
<ol>
<li><code>PendingIntent.getActivity()</code>，适用于启动 Activity 的 Intent</li>
<li><code>PendingIntent.getService()</code>，适用于启动 Service 的 Intent</li>
<li><code>PendingIntent.getBroadcast()</code>，适用于启动 BroadcastReceiver 的 Intent。</li>
</ol>
</blockquote>
<h1 id="常见intent">常见Intent</h1>
<p><a href="https://developer.android.google.cn/guide/components/intents-common">文档</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android广播]]></title>
        <id>https://wl-go.github.io/post/android-guang-bo/</id>
        <link href="https://wl-go.github.io/post/android-guang-bo/">
        </link>
        <updated>2021-01-06T07:12:03.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<ol>
<li>用于Android应用内、Android系统、其他Android应用<code>相互收发广播消息</code>，-发布订阅模式</li>
<li>应用可以<code>注册接收特定的广播</code>，广播发出后，<code>系统</code>会自动将广播传送给同意接收这种广播的应用</li>
<li><code>有关系统广播操作的完整列表</code>，请参阅 Android SDK 中的 BROADCAST_ACTIONS.TXT 文件</li>
</ol>
</blockquote>
<h2 id="接收广播">接收广播</h2>
<h3 id="清单文件声明接收器">清单文件声明接收器</h3>
<blockquote>
<p>注意：如果您的应用以 API 级别 26 或更高级别的平台版本为目标，则不能使用清单为隐式广播（<code>没有明确针对您的应用的广播</code>）声明接收器，但一些<code>不受此限制的隐式广播除外</code>。在大多数情况下，可以使用<code>调度作业来代替</code></p>
</blockquote>
<ol>
<li>在应用清单中指定 <receiver></li>
</ol>
<pre><code class="language-xml">&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot;  android:exported=&quot;false&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.XXXXXX&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre>
<ol start="2">
<li>创建 BroadcastReceiver 子类并实现 onReceive(Context, Intent)</li>
</ol>
<pre><code class="language-kotlin">class MyBroadcastReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {

    }
}    
</code></pre>
<h3 id="上下文注册接收器">上下文注册接收器</h3>
<ol>
<li>创建 <code>BroadcastReceiver</code> 的实例</li>
</ol>
<pre><code class="language-kotlin">val br: BroadcastReceiver = MyBroadcastReceiver()    
</code></pre>
<ol start="2">
<li>创建 <code>IntentFilter</code> 并调用 <code>registerReceiver(BroadcastReceiver, IntentFilter)</code> 来注册接收器</li>
</ol>
<pre><code class="language-kotlin">val filter = IntentFilter(ACTION_1).apply {
    addAction(ACTION_2)
}
registerReceiver(br, filter)
</code></pre>
<ol start="3">
<li>要停止接收广播，请调用 <code>unregisterReceiver(android.content.BroadcastReceiver)</code>，当不再需要接收器或上下文不再有效时，请务必注销接收器</li>
</ol>
<blockquote>
<p>只要注册上下文有效，上下文注册的接收器就会接收广播，例如，如果在 Activity 上下文中注册，只要 Activity 没有被销毁，就会收到广播。如果在应用上下文中注册，只要应用在运行，您就会收到广播</p>
</blockquote>
<h2 id="发送广播">发送广播</h2>
<p>提供三种方式来发送广播：</p>
<ol>
<li><code>sendOrderedBroadcast(Intent, String)</code>方法一次向一个接收器发送广播。当接收器逐个顺序执行时，接收器可以向下传递结果，也可以完全中止广播，使其不再传递给其他接收器。接收器的运行顺序可以通过匹配的<code>intent-filter</code> 的 <code>android:priority</code> 属性来控制；具有相同优先级的接收器将按随机顺序运行。</li>
<li><code>sendBroadcast(Intent)</code> 方法会按随机的顺序向所有接收器发送广播。这称为<code>常规广播</code>。这种方法效率更高，但也意味着接收器无法从其他接收器读取结果，无法传递从广播中收到的数据，也无法中止广播</li>
<li><code>LocalBroadcastManager.sendBroadcast</code> 方法会将广播发送给与发送器位于同一应用中的接收器。如果不需要跨应用发送广播，请使用本地广播。这种实现方法的效率更高（无需进行进程间通信），而且无需担心其他应用在收发您的广播时带来的任何安全问题</li>
</ol>
<pre><code class="language-kotlin">Intent().also { intent -&gt;
    intent.setAction(XXXX)
    intent.putExtra(&quot;data&quot;, &quot;Notice me senpai!&quot;)
    sendBroadcast(intent)
}
</code></pre>
<h2 id="通过权限限制广播">通过权限限制广播</h2>
<blockquote>
<p>可以通过<code>权限将广播限定到拥有特定权限的一组应用</code>，可以对广播的发送器或接收器施加限制。</p>
</blockquote>
<h3 id="带权限的发送">带权限的发送</h3>
<p>当调用 <code>sendBroadcast(Intent, String)</code> 或 <code>sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)</code>时，可以<code>指定权限参数</code>。接收器若要接收此广播，则<code>必须通过其清单中的 标记请求该权限</code>（如果存在危险，则会被授予该权限）</p>
<pre><code>sendBroadcast(Intent(&quot;com.example.xxxxxx&quot;), Manifest.permission.SEND_SMS)

// 要接收此广播，接收方应用必须请求如下权限
&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt;
</code></pre>
<h3 id="带权限的接收">带权限的接收</h3>
<p>如果在<code>注册广播接收器时指定了权限参数</code>（通过 <code>registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)</code>或清单中的<code>&lt;receiver&gt;</code>标记指定），则广播方必须通过其清单中的 <code>&lt;uses-permission&gt;</code> 标记请求该权限（如果存在危险，则会被授予该权限），才能向该接收器发送 Intent</p>
<pre><code>&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot;
    android:permission=&quot;android.permission.SEND_SMS&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.XXXXXX&quot;/&gt;
        &lt;/intent-filter&gt;
&lt;/receiver&gt;

// 或者
var filter = IntentFilter(Intent.XXXXX)
registerReceiver(receiver, filter, Manifest.permission.SEND_SMS, null )
</code></pre>
<h2 id="注意事项">注意事项</h2>
<ol>
<li>
<p><code>系统软件包管理器</code>会在应用安装时<code>注册接收器</code>，然后，该接收器会成为应用的一个<code>独立入口点</code>，这意味着如果应用当前未运行，系统可以启动应用并发送广播</p>
</li>
<li>
<p>系统会创建新的 BroadcastReceiver 组件对象来处理它接收到的每个广播。此对象仅在调用 onReceive(Context, Intent) 期间有效。一旦从此方法返回代码，系统便会认为该组件不再活跃</p>
</li>
<li>
<p>要注册本地广播，请调用 <code>LocalBroadcastManager.registerReceiver(BroadcastReceiver, IntentFilter)</code></p>
</li>
<li>
<p><code>请注意注册和注销接收器的位置</code>，比方说，如果使用 Activity 上下文在 <code>onCreate(Bundle)</code> 中注册接收器，则应在 <code>onDestroy()</code> 中注销，以防接收器从 Activity 上下文中泄露出去。如果在 <code>onResume()</code>中注册接收器，则应在 <code>onPause()</code>中注销，以防多次注册接收器（如果您不想在暂停时接收广播，这样可以减少不必要的系统开销，<code>请勿在 onSaveInstanceState(Bundle) 中注销</code>，因为如果用户在历史记录堆栈中后退，则不会调用此方法。</p>
</li>
<li>
<p><code>广播消息封装在 Intent 对象中</code>。Intent 的操作字符串必须提供应用的 Java 软件包名称语法，并唯一标识广播事件。可以使用 putExtra(String, Bundle) 向 intent 附加其他信息。也可以对 intent 调用 <code>setPackage(String)</code>，将广播限定到同一组织中的一组应用。</p>
</li>
<li>
<p>如果不需要向应用以外的组件发送广播，则可以使用支持库中提供的 <code>LocalBroadcastManager</code>来收发本地广播。LocalBroadcastManager 效率更高（无需进行进程间通信），并且无需考虑其他应用在收发的广播时带来的任何安全问题。本地广播可在应用中作为通用的发布/订阅事件总线，而不会产生任何系统级广播开销</p>
</li>
<li>
<p>如果有许多应用在其清单中注册接收相同的广播，可能会导致系统启动大量应用，从而对设备性能和用户体验造成严重影响。为避免发生这种情况，请优先使用上下文注册而不是清单声明。有时，Android 系统本身会强制使用上下文注册的接收器。例如，CONNECTIVITY_ACTION 广播只会传送给上下文注册的接收器。</p>
</li>
<li>
<p><code>请勿使用隐式 intent 广播敏感信息</code>。任何注册接收广播的应用都可以读取这些信息。可以通过以下三种方式控制哪些应用可以接收您的广播：</p>
<ol>
<li>可以在发送广播时指定权限。</li>
<li>在 Android 4.0 及更高版本中，您可以在发送广播时使用 setPackage(String) 指定软件包。系统会将广播限定到与该软件包匹配的一组应用。</li>
<li>可以使用 LocalBroadcastManager 发送本地广播。</li>
</ol>
</li>
<li>
<p>当注册接收器时，任何应用都可以向您应用的接收器发送潜在的恶意广播。可以通过以下三种方式限制应用可以接收的广播：</p>
<ol>
<li>可以在注册广播接收器时指定权限。</li>
<li>对于清单声明的接收器，可以在清单中将 android:exported 属性设置为“false”。这样一来，接收器就不会接收来自应用外部的广播。</li>
<li>可以使用 LocalBroadcastManager 限制您的应用只接收本地广播。</li>
</ol>
</li>
<li>
<p>广播操作的命名空间是全局性的。请确保在自己的命名空间中编写操作名称和其他字符串，否则可能会无意中与其他应用发生冲突。</p>
</li>
<li>
<p>由于接收器的 onReceive(Context, Intent) 方法在<code>主线程</code>上运行，因此它会快速执行并返回。如果您需要执行长时间运行的工作，请谨慎生成线程或启动后台服务，因为系统可能会在 onReceive() 返回后终止整个进程。建议：</p>
<ol>
<li>在接收器的 <code>onReceive()</code>方法中调用 <code>goAsync()</code>，并将 BroadcastReceiver.PendingResult 传递给后台线程。这样，在从 onReceive() 返回后，广播仍可保持活跃状态。不过，<code>即使采用这种方法，系统仍希望您非常快速地完成广播（在 10 秒以内）</code>。为避免影响主线程，它允许您将工作移到另一个线程。</li>
<li>使用 <code>JobScheduler</code> 调度作业，<a href="https://developer.android.google.cn/guide/background">后台任务</a></li>
</ol>
</li>
<li>
<p>请勿从广播接收器启动 Activity，否则会影响用户体验，尤其是有多个接收器时。相反，可以考虑显示通知。</p>
</li>
</ol>
<h2 id="隐式广播例外情况"><a href="https://developer.android.google.cn/guide/components/broadcast-exceptions">隐式广播例外情况</a></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hilt 依赖注入框架]]></title>
        <id>https://wl-go.github.io/post/hilt-yi-lai-zhu-ru-kuang-jia/</id>
        <link href="https://wl-go.github.io/post/hilt-yi-lai-zhu-ru-kuang-jia/">
        </link>
        <updated>2020-12-31T01:20:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>依赖注入：<code>DI（Dependency Injection）</code> ，<code>Hilt</code>则是Android中的依赖注入框架</p>
</blockquote>
<p><a href="https://developer.android.google.cn/training/dependency-injection/hilt-android">官方文档</a></p>
<h1 id="具体用法">具体用法</h1>
<h2 id="添加依赖">添加依赖</h2>
<pre><code class="language-gradle">// 1. 项目build.gradle
dependencies {
    classpath 'com.google.dagger:hilt-android-gradle-plugin:2.28-alpha'
}

// 2. app/build.gradle
apply plugin: 'kotlin-kapt'
apply plugin: 'dagger.hilt.android.plugin'

dependencies {
    implementation &quot;com.google.dagger:hilt-android:2.28-alpha&quot;
    kapt &quot;com.google.dagger:hilt-android-compiler:2.28-alpha&quot;
}
</code></pre>
<h2 id="基本用法">基本用法</h2>
<h3 id="必须hiltandroidapp">必须（@HiltAndroidApp）</h3>
<p>自定义Application类，使用<code>@HiltAndroidApp</code> 注解该类，否则Hilt无法正常使用</p>
<blockquote>
<p><code>@HiltAndroidApp</code> 会触发 Hilt 的代码生成操作，生成的代码包括应用的一个基类，该基类充当应用级依赖项容器，生成的这一 Hilt 组件会附加到 <code>Application</code> 对象的生命周期，并为其提供依赖项，此外，它也是应用的父组件，这意味着，<code>其他组件可以访问它提供的依赖项</code>。</p>
</blockquote>
<pre><code class="language-kotlin">@HiltAndroidApp
class MyApp : Application() {
}
</code></pre>
<h3 id="6个注入入口点">6个注入入口点</h3>
<ul>
<li>Application</li>
<li>Activity</li>
<li>Fragment</li>
<li>View</li>
<li>Service</li>
<li>BroadcastReceiver</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>只有<code>Application入口点</code>使用<code>@HiltAndroidApp</code>，其余的都是使用<code>@AndroidEntryPoint</code>注解来声明的</li>
<li>使用 <code>@AndroidEntryPoint</code> 为某个 Android 类添加注释，则还必须为依赖于该类的 Android 类添加注释。<code>例如，如为某个 Fragment 添加注释，则还必须为使用该 Fragment 的所有 Activity 添加注释。</code></li>
<li><code>@AndroidEntryPoint</code> 会为项目中的每个 Android 类生成一个<code>单独的 Hilt 组件</code>。这些组件可以<strong>从它们各自的父类接收依赖项</strong>，<a href="https://developer.android.google.cn/training/dependency-injection/hilt-android#component-hierarchy"><strong><code>组件层次结构</code></strong></a></li>
</ol>
<p><strong>比如，Activity需要依赖注入</strong></p>
<pre><code class="language-kotlin">@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
}
</code></pre>
<h3 id="组件中声明依赖项inject">组件中声明依赖项（@Inject）</h3>
<blockquote>
<p>通过在组件中字段上添加<code>@Inject注解</code>，声明这个字段是个依赖项，需要通过依赖注入提供实例</p>
</blockquote>
<pre><code class="language-kotlin">@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    // 声明依赖项
    @Inject lateinit var a: A

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
}
</code></pre>
<h3 id="告知hilt如何提供依赖项">告知Hilt，如何提供依赖项</h3>
<h4 id="1-构造函数方式inject">1. 构造函数方式（@Inject）</h4>
<blockquote>
<p>通过在类的构造函数上添加<code>@Inject</code>注解，如果其构造函数中有依赖项，那么对应的类也需要告知Hilt如何提供实例</p>
</blockquote>
<pre><code class="language-kotlin">class A @Inject constructor() {
    fun doA() {
        println(&quot;AAAAA&quot;)
    }
}
</code></pre>
<h4 id="2-对接口的依赖注入">2. 对接口的依赖注入</h4>
<blockquote>
<p>接口是不可以通过构造函数的方式实现注入的，接口根本没有构造函数，这是时候需要 <code>@Module、@InstanllIn、@Qualifier、@Binds</code> ，同一类型不同实例的注入需要定义注解（用于区分）并且添加<code>@Qualifier</code></p>
</blockquote>
<p><strong>实例：</strong></p>
<ol>
<li>定义接口</li>
</ol>
<pre><code class="language-kotlin">interface IAction{
    fun doA()
    fun doB()
}
</code></pre>
<ol start="2">
<li>定义两个实现类（需要添加<code>@Inject</code>告诉<code>hilt</code>可以通过构造函数注入）</li>
</ol>
<pre><code class="language-kotlin">class A @Inject constructor(): IAction{
    override fun doA(){
        println(&quot;A - doA&quot;)
    }
    override fun doB(){
        println(&quot;A - doB&quot;)
    }
}

class B @Inject constructor(): IAction{
    override fun doA(){
        println(&quot;B - doA&quot;)
    }
    override fun doB(){
        println(&quot;B - doB&quot;)
    }
}
</code></pre>
<ol start="3">
<li>使用<code>@Qualifier</code>，创建注解（区分IAction类型，实现IAction的类存在多个）</li>
</ol>
<pre><code class="language-kotlin">@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class BindAIAction()

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class BindBIAction()
</code></pre>
<ol start="4">
<li>使用<code>@Module</code>、<code>@InstallIn</code>、<code>@Binds</code> 创建注入项模版</li>
</ol>
<pre><code class="language-kotlin">@Module
@InstallIn(ActivityComponent::class)
abstract class ActionModule {

    @BindAIAction
    @Binds
    abstract fun bindA(a: A): IAction

    @BindBIAction
    @Binds
    abstract fun bindB(b: B): IAction

    // 这里的 @BindAIAction，@BindBIAction主要就是区分，注入时的具体实现类是哪个
}
</code></pre>
<ol start="5">
<li>注入接口类型（这里也使用了自定义的注解，为了区分具体注入哪个实现类）</li>
</ol>
<pre><code class="language-kotlin">class Test{
    @BindAIAction // A
    @Inject
    lateinit var mA: IAction

    @@BindBIAction// B
    @Inject
    lateinit var mB: IAction
}
</code></pre>
<h4 id="3-第三方类的依赖注入">3. 第三方类的依赖注入</h4>
<blockquote>
<p>一般像三方库的类，比如<code>OkHttpClient</code>、<code>Retrofit</code>，需要使用<code>@Module、@InstanllIn、@Provides</code><br>
<strong>注意：这时使用<code>@Module</code>注解的不是抽象类了，而是一个普通的class，<code>@Provides</code>注解的是普通方法，需要有返回类型，这个返回类型就是需要提供的注入的实例</strong></p>
</blockquote>
<p><strong>实例</strong></p>
<pre><code class="language-kotlin">@Module
@InstallIn(ActivityComponent::class)
class httpModule{

    @Provides
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .build()
    }

    // 这里的OkHttpClient参数，就不需要定义了，因为上面已经有了
    @Provides
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .addConverterFactory(GsonConverterFactory.create())
            .baseUrl(&quot;http://127.0.0.1&quot;)
            .client(okHttpClient)
            .build()
    }
}
</code></pre>
<h2 id="hilt内置组件和组件作用域">Hilt内置组件和组件作用域</h2>
<h3 id="内置组件使用installin">内置组件使用（@InstallIn）</h3>
<blockquote>
<p><code>@InstallIn(hilt组件)</code><br>
比如：<code>ActivityComponent::class</code>，<code>@InstallIn(ActivityComponent::class)</code>，表示把这个模块安装到Activity组件当中，那么Activity、Activity中包含的Fragment和View也可以使用，其他地方无法使用</p>
</blockquote>
<h4 id="7种组件类型分别用于注入到不同的场景">7种组件类型，分别用于注入到不同的场景</h4>
<table>
<thead>
<tr>
<th>Hilt 组件</th>
<th>注入场景</th>
<th>作用域</th>
</tr>
</thead>
<tbody>
<tr>
<td>ApplictionComponent</td>
<td>Appliction</td>
<td>@Singleton</td>
</tr>
<tr>
<td>ActivityRetainedComponet</td>
<td>ViewModel</td>
<td>@ActivityRetainedScope</td>
</tr>
<tr>
<td>ActivityComponent</td>
<td>Activity</td>
<td>@ActivityScope</td>
</tr>
<tr>
<td>FragmentComponent</td>
<td>Fragment</td>
<td>@FragmentScope</td>
</tr>
<tr>
<td>ViewComponent</td>
<td>View</td>
<td>@ViewScope</td>
</tr>
<tr>
<td>ViewWithFragmentComponent</td>
<td>View annotated with @WithFragmentBindings</td>
<td>@ViewScope</td>
</tr>
<tr>
<td>ServiceComponent</td>
<td>Service</td>
<td>@ServiceScope</td>
</tr>
</tbody>
</table>
<h3 id="组件作用域">组件作用域</h3>
<ol>
<li>依上面表格，如果想要在<code>全程序范围内共用某个对象的实例</code>，那么就使用<code>@Singleton</code>。如果想要在某个<code>Activity</code>，以及它内部包含的<code>Fragment</code>和<code>View</code>中共用某个对象的实例，那么就使用<code>@ActivityScoped</code></li>
<li>没必要非得在Moudle中使用<code>作用域注解</code>，也可以直接在任何可注入类得上方使用</li>
</ol>
<pre><code class="language-kotlin">    @Singleton
    class A @Inject constructor() {
    }

    // 也可以
    @Module
    @InstallIn(ActivityComponent::class)
    abstract class ActionModule {
        @Singleton // 作用域
        @BindAIAction
        @Binds
        abstract fun bindA(a: A): IAction
    }
</code></pre>
<h2 id="预置qualifier-系统组件的注入">预置Qualifier （系统组件的注入）</h2>
<blockquote>
<p>专门就是用于给我们<code>提供Context类型</code>的依赖注入实例，对于某些依赖于Context类型的类，<code>@ApplicationContext</code>，<code>@ActivityContext</code></p>
</blockquote>
<h3 id="context-注入实例">Context 注入——实例</h3>
<pre><code class="language-kotlin">// ApplicationContext 全局的
@Singleton
class A @Inject constructor(@ApplicationContext val context: Context) {}

// 某个Activity 上下文
@ActivityScope
class B @Inject constructor(@ActivityContext val context: Context) {}
</code></pre>
<h3 id="application和activity-注入实例">Application和Activity 注入——实例</h3>
<blockquote>
<p><strong>注意必须是Application和Activity这两个类型，即使是声明它们的子类型，编译都无法通过</strong>，<code>**Hilt自动就能识别它们**</code></p>
</blockquote>
<pre><code class="language-kotlin">class A @Inject constructor(val application: Application) {
}

class B @Inject constructor(val activity: Activity) {
}
</code></pre>
<h2 id="转换hilt注入的appliction实例">转换Hilt注入的Appliction实例</h2>
<pre><code class="language-kotlin">@Module
@InstallIn(ApplicationComponent::class)
class ApplicationModule {

    @Provides
    fun provideMyApplication(application: Application): MyApplication {
        return application as MyApplication
    }
}
</code></pre>
<h2 id="viewmodel-依赖注入方式-viewmodelinject">ViewModel 依赖注入方式  @ViewModelInject</h2>
<h3 id="添加依赖appbuildgradle">添加依赖app/build.gradle</h3>
<pre><code class="language-gradle">dependencies {
    implementation 'androidx.hilt:hilt-lifecycle-viewmodel:1.0.0-alpha02'
    kapt 'androidx.hilt:hilt-compiler:1.0.0-alpha02'
}
</code></pre>
<h3 id="使用viewmodelinject">使用@ViewModelInject</h3>
<pre><code class="language-kotlin">class MainViewModel @ViewModelInject constructor(private val mainRepository: MainRepository) :
    ViewModel() {
}
</code></pre>
<p>使用@ViewModelInject，在MainViewModel上方就<code>不需要</code>添加组件作用域注解<code>@ActivityRetainedScoped</code>，其次，在获取ViewModel的方式还是使用<code>ViewModelProvider</code></p>
<pre><code class="language-kotlin">private val mainViewModel: MainViewModel by lazy {
    ViewModelProvider(this).get(MainViewModel::class.java)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin——作用域函数]]></title>
        <id>https://wl-go.github.io/post/kotlin-zuo-yong-yu-han-shu/</id>
        <link href="https://wl-go.github.io/post/kotlin-zuo-yong-yu-han-shu/">
        </link>
        <updated>2020-12-28T08:40:56.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>学习Kotlin官方文档的记录</p>
</blockquote>
<p><code>let</code>、<code>run</code>、<code>with</code>、<code>apply</code> 以及 <code>also</code></p>
<p><a href="let">let</a></p>
<p>这些函数的作用：<strong>在一个对象上执行一个代码块（<code>Lambda表达式</code>），不同的是这个对象在块中如何使用，以及整个表达式的结果是什么</strong></p>
<h1 id="let">let</h1>
<blockquote>
<p>上下文对象作为 lambda 表达式的<code>参数（it）</code>来访问。<font style='color:red'>返回值是<code>lambda 表达式的结果</code></font></p>
</blockquote>
<h2 id="在调用链的结果上调用一个或多个函数">在调用链的结果上调用一个或多个函数</h2>
<pre><code class="language-kotlin">val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;)
val resultList = numbers.map { it.length }.filter { it &gt; 3 }
println(resultList)
// 使用let简化，不需要resultList变量
// 若代码块仅包含以 it 作为参数的单个函数，则可以使用方法引用(::)代替 lambda 表达式
// ::println -&gt; println(it)
numbers.map { it.length }.filter { it &gt; 3 }.let{::println} 
</code></pre>
<h2 id="用于仅使用非空值执行代码块">用于仅使用非空值执行代码块</h2>
<blockquote>
<p>如需对非空对象执行操作，可对其使用安全调用操作符 <code>?.</code>并调用 <code>let</code> 在 lambda 表达式中执行操作</p>
</blockquote>
<pre><code class="language-kotlin">val str: String? = &quot;Hello&quot; 
val length = str?.let { 
    println(&quot;$it&quot;)
    it.length
}
</code></pre>
<h2 id="引入作用域受限的局部变量以提高代码的可读性">引入作用域受限的局部变量以提高代码的可读性</h2>
<blockquote>
<p>如需为上下文对象定义一个新变量，可提供其名称作为 lambda 表达式参数来替默认的 it</p>
</blockquote>
<pre><code class="language-kotlin">val numbers = listOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)
val modifiedFirstItem = numbers.first().let { firstItem -&gt;
    println(&quot;$firstItem&quot;)
    if (firstItem.length &gt;= 5) firstItem else &quot;!&quot; + firstItem + &quot;!&quot;
}.toUpperCase()
println(&quot;$modifiedFirstItem&quot;)
</code></pre>
<h1 id="with">with</h1>
<blockquote>
<p>一个非扩展函数：<code>上下文对象作为参数传递</code>，但是在 lambda 表达式内部，它可以作为<code>接收者（this）使用</code>。 <font style='color:red'>返回值是 lambda 表达式结果</font></p>
</blockquote>
<blockquote>
<p><em>建议使用 <code>with</code> 来调用上下文对象上的函数，而不使用 lambda 表达式结果。 在代码中，with 可以理解为<code>“对于这个对象，执行以下操作。”</code></em></p>
</blockquote>
<h2 id="对于这个对象执行以下操作">对于这个对象，执行以下操作</h2>
<pre><code class="language-kotlin">val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
with(numbers) {
    println(&quot;'with' is called with argument $this&quot;)
    println(&quot;It contains $size elements&quot;)
}
</code></pre>
<h2 id="引入一个辅助对象其属性或函数将用于计算一个值">引入一个辅助对象，其属性或函数将用于计算一个值</h2>
<pre><code class="language-kotlin">val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
val firstAndLast = with(numbers) {
    &quot;The first element is ${first()},&quot; +
    &quot; the last element is ${last()}&quot;
}
println(firstAndLast)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android常用Intent]]></title>
        <id>https://wl-go.github.io/post/android-chang-yong-intent/</id>
        <link href="https://wl-go.github.io/post/android-chang-yong-intent/">
        </link>
        <updated>2020-12-28T07:23:00.000Z</updated>
        <content type="html"><![CDATA[<p>记录有关常用<code>Intent</code>使用</p>
<p>⚠️注意：</p>
<ol>
<li>清单文件中添加需要的权限</li>
<li>有些<code>Intent</code>使用需要<code>动态权限申请</code></li>
<li>使用前，记得判断是否存在可处理Intent的对象，<code>intent.resolveActivity(packageManager) != null</code></li>
</ol>
<h1 id="拨打电话">拨打电话</h1>
<ol>
<li>
<p>添加权限<br>
<code>&lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot; /&gt;</code></p>
</li>
<li>
<p>Action</p>
<ul>
<li><code>Intent.ACTION_DIAL</code> - 打开拨号器或电话应用</li>
<li><code>Intent.ACTION_CALL</code> - 拨打电话（<strong>需要 CALL_PHONE 权限</strong>）<color style='color:red'>注意：直接把电话打出去了</color></li>
</ul>
</li>
<li>
<p>data数据URI</p>
<ul>
<li><code>tel:</code>电话号码</li>
<li><code>voicemail:</code>电话号码</li>
</ul>
</li>
<li>
<p>示例代码</p>
</li>
</ol>
<p><strong>4.1 直接拨号，需要动态权限</strong></p>
<pre><code class="language-kotlin">    // 直接拨号，需要动态权限
    private fun callPhone(){
        if (ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.CALL_PHONE
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            ActivityCompat.requestPermissions(
                this, arrayOf(Manifest.permission.CALL_PHONE), 101
            )
        } else {
            val callPhoneIntent = Intent(Intent.ACTION_CALL).apply {
                data = Uri.parse(&quot;tel:11111111111&quot;)
            }
            // 判断是否存在能处理此Intent的目标
            if (callPhoneIntent.resolveActivity(packageManager) != null) {
                startActivity(callPhoneIntent)
            } else {
                Toast.makeText(this, &quot;抱歉，此设备找不到拨号应用&quot;, Toast.LENGTH_SHORT).show()
            }
        }
    }

</code></pre>
<p><strong>4.2 去系统拨号界面</strong></p>
<pre><code class="language-kotlin">private fun goCallPhone(){
        val callPhoneIntent = Intent(Intent.ACTION_DIAL).apply {
            data = Uri.parse(&quot;tel:11111111111&quot;)
        }
        // 判断是否存在能处理此Intent的目标
        if (callPhoneIntent.resolveActivity(packageManager) != null) {
            startActivity(callPhoneIntent)
        } else {
            Toast.makeText(this, &quot;抱歉，此设备找不到拨号应用&quot;, Toast.LENGTH_SHORT).show()
        }
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android资源文件——Drawable状态列表资源]]></title>
        <id>https://wl-go.github.io/post/android-zi-yuan-wen-jian-drawable-zhuang-tai-lie-biao-zi-yuan/</id>
        <link href="https://wl-go.github.io/post/android-zi-yuan-wen-jian-drawable-zhuang-tai-lie-biao-zi-yuan/">
        </link>
        <updated>2020-12-28T07:12:28.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>StateListDrawable 是在 XML 文件中定义的可绘制对象，它会根据对象状态，使用多个不同的图像来表示同一个图形。<br>
例如，Button 可以是多种不同状态（按下、聚焦或这两种状态都不是）中的其中一种，并且您可利用状态列表可绘制对象，为每种状态提供不同的背景图片。<br>
在每个状态变更期间，将从上到下遍历状态列表，并使用第一个与当前状态匹配的项目。</p>
</blockquote>
<h1 id="文件位置">文件位置</h1>
<p><code>res/drawable/filename.xml</code></p>
<h1 id="编译后的资源数据类型">编译后的资源数据类型</h1>
<p><code>指向 StateListDrawable 的资源指针</code></p>
<h1 id="资源引用">资源引用</h1>
<ol>
<li>代码中：<code>R.drawable.filename</code></li>
<li>xml中：<code>@[package:]drawable/filename</code></li>
</ol>
<h1 id="语法">语法</h1>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:constantSize=[&quot;true&quot; | &quot;false&quot;]
    android:dither=[&quot;true&quot; | &quot;false&quot;]
    android:variablePadding=[&quot;true&quot; | &quot;false&quot;] &gt;
    &lt;item
        android:drawable=&quot;@[package:]drawable/drawable_resource&quot;
        android:state_pressed=[&quot;true&quot; | &quot;false&quot;]
        android:state_focused=[&quot;true&quot; | &quot;false&quot;]
        android:state_hovered=[&quot;true&quot; | &quot;false&quot;]
        android:state_selected=[&quot;true&quot; | &quot;false&quot;]
        android:state_checkable=[&quot;true&quot; | &quot;false&quot;]
        android:state_checked=[&quot;true&quot; | &quot;false&quot;]
        android:state_enabled=[&quot;true&quot; | &quot;false&quot;]
        android:state_activated=[&quot;true&quot; | &quot;false&quot;]
        android:state_window_focused=[&quot;true&quot; | &quot;false&quot;] /&gt;
&lt;/selector&gt;
</code></pre>
<h1 id="元素说明">元素说明</h1>
<table>
<thead>
<tr>
<th>元素名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>selector</td>
<td>根元素，里面包含一个或多个item</td>
</tr>
<tr>
<td>android:constantSize</td>
<td>布尔值。如果可绘制对象报告的内部大小在状态变更时保持不变，则值为“true”（大小是所有状态的最大值）</td>
</tr>
<tr>
<td>android:dither</td>
<td>布尔值。值为“true”时，将在位图的像素配置与屏幕不同时（例如：ARGB 8888 位图和 RGB 565 屏幕）启用位图的抖动</td>
</tr>
<tr>
<td>android:variablePadding</td>
<td>布尔值。如果可绘制对象的内边距应根据选择的当前状态而变化，则值为“true”</td>
</tr>
<tr>
<td>item</td>
<td>定义在某些状态下使用的drawable，状态通过其属性来描述</td>
</tr>
<tr>
<td><em>item 属性</em></td>
<td></td>
</tr>
<tr>
<td>android:drawable</td>
<td>可绘制对象资源</td>
</tr>
<tr>
<td>android:state_pressed</td>
<td>布尔值，在按下对象时（例如轻触/点按了按钮时）使用，则为“true”</td>
</tr>
<tr>
<td>android:state_focused</td>
<td>布尔值。如果此项应在聚焦对象时（例如使用轨迹球/方向键突出显示按钮时）使用，则为“true”</td>
</tr>
<tr>
<td>android:state_selected</td>
<td>布尔值。如果此项应在选择对象时（例如打开标签页时）使用，则为“true”</td>
</tr>
<tr>
<td>android:state_checkable</td>
<td>布尔值。如果此项应在对象可勾选时使用，则为“true”，仅适用于对象可在可勾选和不可勾选的微件之间转换的情况</td>
</tr>
<tr>
<td>android:state_checked</td>
<td>布尔值。如果此项应在勾选对象时使用，则为“true”</td>
</tr>
<tr>
<td>android:state_enabled</td>
<td>布尔值。如果此项应在启用对象（能够接收轻触/点按事件）时使用</td>
</tr>
<tr>
<td>android:state_window_focused</td>
<td>布尔值。如果此项应在应用窗口具有焦点（应用位于前台）时使用，则为“true”</td>
</tr>
<tr>
<td>android:state_hovered</td>
<td>布尔值。如果当光标悬停在对象上时应使用此项目，则值为“true”，此项为 API 级别 14 新引入的配置</td>
</tr>
<tr>
<td>android:state_activated</td>
<td>布尔值。如果在对象激活作为持续选择（例如，在持续导航视图中“突出显示”之前选中的列表项）时应使用此项目，则值为“true”</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android资源文件——颜色状态列表资源]]></title>
        <id>https://wl-go.github.io/post/android-zi-yuan-wen-jian-yan-se-zhuang-tai-lie-biao-zi-yuan/</id>
        <link href="https://wl-go.github.io/post/android-zi-yuan-wen-jian-yan-se-zhuang-tai-lie-biao-zi-yuan/">
        </link>
        <updated>2020-12-28T06:36:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>ColorStateList 是一个可以在 XML 中定义的对象，可以<code>将其作为颜色来使用</code>，但它实际上会更改颜色，具体取决于其应用到的View 对象的状态。例如，<code>Button可能处于多种不同状态中的一种（按下、聚焦或既不按下也不聚焦），而使用颜色状态列表，可以为每种状态提供不同的颜色。</code>在每次状态更改期间，系统将从上到下遍历状态列表，并且将使用与当前状态匹配的第一项。</p>
</blockquote>
<h1 id="文件位置">文件位置</h1>
<p><code>res/color/filename.xml</code></p>
<h1 id="编译后的资源数据类型">编译后的资源数据类型</h1>
<p><code>指向 ColorStateList 的资源指针</code></p>
<h1 id="资源引用">资源引用</h1>
<ol>
<li>代码中：<code>R.color.filename</code></li>
<li>xml中：<code>@[package:]color/filename</code></li>
</ol>
<h1 id="语法">语法</h1>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;
        &lt;item
            android:color=&quot;hex_color&quot;
            android:state_pressed=[&quot;true&quot; | &quot;false&quot;]
            android:state_focused=[&quot;true&quot; | &quot;false&quot;]
            android:state_selected=[&quot;true&quot; | &quot;false&quot;]
            android:state_checkable=[&quot;true&quot; | &quot;false&quot;]
            android:state_checked=[&quot;true&quot; | &quot;false&quot;]
            android:state_enabled=[&quot;true&quot; | &quot;false&quot;]
            android:state_window_focused=[&quot;true&quot; | &quot;false&quot;] /&gt;
    &lt;/selector&gt;
</code></pre>
<h1 id="元素说明">元素说明</h1>
<table>
<thead>
<tr>
<th>元素名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>selector</td>
<td>根元素，里面包含一个或多个item</td>
</tr>
<tr>
<td>item</td>
<td>定义在某些状态下使用的颜色，状态通过其属性来描述</td>
</tr>
<tr>
<td><em>item 属性</em></td>
<td></td>
</tr>
<tr>
<td>android:color</td>
<td>十六进制颜色</td>
</tr>
<tr>
<td>android:state_pressed</td>
<td>布尔值，在按下对象时（例如轻触/点按了按钮时）使用，则为“true”</td>
</tr>
<tr>
<td>android:state_focused</td>
<td>布尔值。如果此项应在聚焦对象时（例如使用轨迹球/方向键突出显示按钮时）使用，则为“true”</td>
</tr>
<tr>
<td>android:state_selected</td>
<td>布尔值。如果此项应在选择对象时（例如打开标签页时）使用，则为“true”</td>
</tr>
<tr>
<td>android:state_checkable</td>
<td>布尔值。如果此项应在对象可勾选时使用，则为“true”，仅适用于对象可在可勾选和不可勾选的微件之间转换的情况</td>
</tr>
<tr>
<td>android:state_checked</td>
<td>布尔值。如果此项应在勾选对象时使用，则为“true”</td>
</tr>
<tr>
<td>android:state_enabled</td>
<td>布尔值。如果此项应在启用对象（能够接收轻触/点按事件）时使用</td>
</tr>
<tr>
<td>android:state_window_focused</td>
<td>布尔值。如果此项应在应用窗口具有焦点（应用位于前台）时使用，则为“true”</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android开发规范手册]]></title>
        <id>https://wl-go.github.io/post/android-kai-fa-gui-fan-shou-ce/</id>
        <link href="https://wl-go.github.io/post/android-kai-fa-gui-fan-shou-ce/">
        </link>
        <updated>2020-12-28T05:14:41.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>学习《阿里巴巴Android开发手册》笔记</p>
</blockquote>
<h1 id="android资源文件命名">Android资源文件命名</h1>
<blockquote>
<p>小写单词+下划线的方式命名</p>
</blockquote>
<ol>
<li>
<p><strong>资源文件</strong>命名带上<strong>模块名称</strong></p>
</li>
<li>
<p><strong>layout文件</strong>的命名方式</p>
<ul>
<li>Activity 的 layout 以 <strong>module_activity</strong> 开头</li>
<li>Fragment 的 layout 以 <strong>module_fragment</strong> 开头</li>
<li>Dialog 的 layout 以 <strong>module_dialog</strong> 开头</li>
<li>include 的 layout 以 <strong>module_include</strong> 开头</li>
<li>ListView 的行 layout 以 <strong>module_list_item</strong> 开头</li>
<li>RecyclerView 的 item layout 以 <strong>module_recycle_item</strong> 开头</li>
<li>GridView 的行 layout 以 <strong>module_grid_item</strong> 开头</li>
</ul>
</li>
<li>
<p><strong>drawable 资源名称</strong></p>
</li>
</ol>
<blockquote>
<p>模块名_业务功能描述_控件描述_控件状态限定词<br>
<code>module_login_btn_pressed</code></p>
</blockquote>
<ol start="4">
<li><strong>anim 资源名称</strong></li>
</ol>
<blockquote>
<p>模块名_逻辑名称_[方向|序号]<br>
<code>tween 动画资源 ： 尽可能以通用的动画名称命名，如 module_fade_in ,module_fade_out ,module_push_down_in (动画+方向)；</code><br>
<code>frame 动画资源：尽可能以模 块+功能命名+序号。如：module_loading_grey_001</code></p>
</blockquote>
<ol start="5">
<li><strong>color 资源，module_colors.xml</strong></li>
</ol>
<blockquote>
<p>模块名_逻辑名称_颜色，#AARRGGBB 格式<br>
<code>&lt;color name=&quot;module_btn_bg_color&quot;&gt;#FF550055&lt;/color&gt;</code></p>
</blockquote>
<ol start="6">
<li><strong>dimen 资源，module_dimens.xml</strong></li>
</ol>
<blockquote>
<p>模块名_描述信息<br>
<code>&lt;dimen name=&quot;module_horizontal_line_height&quot;&gt;1dp&lt;/dimen&gt;</code></p>
</blockquote>
<ol start="7">
<li><strong>style 资源，module_styles.xml</strong></li>
</ol>
<blockquote>
<p>父 style 名称.当前 style 名称</p>
</blockquote>
<ol start="8">
<li><strong>string资源，module_strings.xml</strong></li>
</ol>
<blockquote>
<p>模块名_逻辑名称<br>
<code>moudule_login_tips,module_homepage_notice_desc</code></p>
</blockquote>
<ol start="9">
<li>** Id 资源缩写表**<br>
| 控件             | 缩写 |<br>
| ---------------- | ---- |<br>
| LinearLayout     | ll   |<br>
| RelativeLayout   | rl   |<br>
| ConstraintLayout | cl   |<br>
| ListView         | lv   |<br>
| ScollView        | sv   |<br>
| TextView         | tv   |<br>
| Button           | btn  |<br>
| ImageView        | iv   |<br>
| CheckBox         | cb   |<br>
| RadioButton      | rb   |<br>
| EditText         | et   |<br>
| <strong>其他控件</strong>         | ---    |<br>
| ProgressBar | progress_bar |<br>
| DatePicker | date_picker |</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[迭代器模式（Iterator）]]></title>
        <id>https://wl-go.github.io/post/die-dai-qi-mo-shi-iterator/</id>
        <link href="https://wl-go.github.io/post/die-dai-qi-mo-shi-iterator/">
        </link>
        <updated>2020-12-28T03:29:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote></blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文学摘要]]></title>
        <id>https://wl-go.github.io/post/wen-xue-zhai-yao/</id>
        <link href="https://wl-go.github.io/post/wen-xue-zhai-yao/">
        </link>
        <updated>2020-12-28T02:37:11.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>求知若渴，虚心若愚</p>
</li>
<li>
<p>原句：天才就是1%的灵感加上99%的汗水，但那1%的灵感是最重要的，甚至比那99%的汗水都要重要。——爱迪生</p>
</li>
<li>
<p>网络摘取</p>
</li>
</ul>
<pre><code>    知人不必言尽 留些口德

    责人不必苛尽 留些肚量

    锋芒不必露尽 留些深敛

    有功不必邀尽 留些谦让

    得理不必争尽 留些宽容

    富贵不必享尽 留些福泽
</code></pre>
<h2 id="白岩松白说">白岩松《白说》</h2>
<ul>
<li>面对现实说话，你的困扰是：树欲静而风不止。而你唯一能做出的选择是：无论风怎样动，树静。</li>
</ul>
]]></content>
    </entry>
</feed>