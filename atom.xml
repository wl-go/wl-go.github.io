<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wl-go.github.io</id>
    <title>wlgo 博客</title>
    <updated>2021-01-06T08:28:55.762Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wl-go.github.io"/>
    <link rel="self" href="https://wl-go.github.io/atom.xml"/>
    <subtitle>记录学习中的点点滴滴！</subtitle>
    <logo>https://wl-go.github.io/images/avatar.png</logo>
    <icon>https://wl-go.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, wlgo 博客</rights>
    <entry>
        <title type="html"><![CDATA[Android广播]]></title>
        <id>https://wl-go.github.io/post/android-guang-bo/</id>
        <link href="https://wl-go.github.io/post/android-guang-bo/">
        </link>
        <updated>2021-01-06T07:12:03.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<ol>
<li>用于Android应用内、Android系统、其他Android应用<code>相互收发广播消息</code>，-发布订阅模式</li>
<li>应用可以<code>注册接收特定的广播</code>，广播发出后，<code>系统</code>会自动将广播传送给同意接收这种广播的应用</li>
<li><code>有关系统广播操作的完整列表</code>，请参阅 Android SDK 中的 BROADCAST_ACTIONS.TXT 文件</li>
</ol>
</blockquote>
<h2 id="接收广播">接收广播</h2>
<h3 id="清单文件声明接收器">清单文件声明接收器</h3>
<blockquote>
<p>注意：如果您的应用以 API 级别 26 或更高级别的平台版本为目标，则不能使用清单为隐式广播（<code>没有明确针对您的应用的广播</code>）声明接收器，但一些<code>不受此限制的隐式广播除外</code>。在大多数情况下，可以使用<code>调度作业来代替</code></p>
</blockquote>
<ol>
<li>在应用清单中指定 <receiver></li>
</ol>
<pre><code class="language-xml">&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot;  android:exported=&quot;false&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.XXXXXX&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre>
<ol start="2">
<li>创建 BroadcastReceiver 子类并实现 onReceive(Context, Intent)</li>
</ol>
<pre><code class="language-kotlin">class MyBroadcastReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {

    }
}    
</code></pre>
<h3 id="上下文注册接收器">上下文注册接收器</h3>
<ol>
<li>创建 <code>BroadcastReceiver</code> 的实例</li>
</ol>
<pre><code class="language-kotlin">val br: BroadcastReceiver = MyBroadcastReceiver()    
</code></pre>
<ol start="2">
<li>创建 <code>IntentFilter</code> 并调用 <code>registerReceiver(BroadcastReceiver, IntentFilter)</code> 来注册接收器</li>
</ol>
<pre><code class="language-kotlin">val filter = IntentFilter(ACTION_1).apply {
    addAction(ACTION_2)
}
registerReceiver(br, filter)
</code></pre>
<ol start="3">
<li>要停止接收广播，请调用 <code>unregisterReceiver(android.content.BroadcastReceiver)</code>，当不再需要接收器或上下文不再有效时，请务必注销接收器</li>
</ol>
<blockquote>
<p>只要注册上下文有效，上下文注册的接收器就会接收广播，例如，如果在 Activity 上下文中注册，只要 Activity 没有被销毁，就会收到广播。如果在应用上下文中注册，只要应用在运行，您就会收到广播</p>
</blockquote>
<h2 id="发送广播">发送广播</h2>
<p>提供三种方式来发送广播：</p>
<ol>
<li><code>sendOrderedBroadcast(Intent, String)</code>方法一次向一个接收器发送广播。当接收器逐个顺序执行时，接收器可以向下传递结果，也可以完全中止广播，使其不再传递给其他接收器。接收器的运行顺序可以通过匹配的<code>intent-filter</code> 的 <code>android:priority</code> 属性来控制；具有相同优先级的接收器将按随机顺序运行。</li>
<li><code>sendBroadcast(Intent)</code> 方法会按随机的顺序向所有接收器发送广播。这称为<code>常规广播</code>。这种方法效率更高，但也意味着接收器无法从其他接收器读取结果，无法传递从广播中收到的数据，也无法中止广播</li>
<li><code>LocalBroadcastManager.sendBroadcast</code> 方法会将广播发送给与发送器位于同一应用中的接收器。如果不需要跨应用发送广播，请使用本地广播。这种实现方法的效率更高（无需进行进程间通信），而且无需担心其他应用在收发您的广播时带来的任何安全问题</li>
</ol>
<pre><code class="language-kotlin">Intent().also { intent -&gt;
    intent.setAction(XXXX)
    intent.putExtra(&quot;data&quot;, &quot;Notice me senpai!&quot;)
    sendBroadcast(intent)
}
</code></pre>
<h2 id="通过权限限制广播">通过权限限制广播</h2>
<blockquote>
<p>可以通过<code>权限将广播限定到拥有特定权限的一组应用</code>，可以对广播的发送器或接收器施加限制。</p>
</blockquote>
<h3 id="带权限的发送">带权限的发送</h3>
<p>当调用 <code>sendBroadcast(Intent, String)</code> 或 <code>sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)</code>时，可以<code>指定权限参数</code>。接收器若要接收此广播，则<code>必须通过其清单中的 标记请求该权限</code>（如果存在危险，则会被授予该权限）</p>
<pre><code>sendBroadcast(Intent(&quot;com.example.xxxxxx&quot;), Manifest.permission.SEND_SMS)

// 要接收此广播，接收方应用必须请求如下权限
&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt;
</code></pre>
<h3 id="带权限的接收">带权限的接收</h3>
<p>如果在<code>注册广播接收器时指定了权限参数</code>（通过 <code>registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)</code>或清单中的<code>&lt;receiver&gt;</code>标记指定），则广播方必须通过其清单中的 <code>&lt;uses-permission&gt;</code> 标记请求该权限（如果存在危险，则会被授予该权限），才能向该接收器发送 Intent</p>
<pre><code>&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot;
    android:permission=&quot;android.permission.SEND_SMS&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.XXXXXX&quot;/&gt;
        &lt;/intent-filter&gt;
&lt;/receiver&gt;

// 或者
var filter = IntentFilter(Intent.XXXXX)
registerReceiver(receiver, filter, Manifest.permission.SEND_SMS, null )
</code></pre>
<h2 id="注意事项">注意事项</h2>
<ol>
<li>
<p><code>系统软件包管理器</code>会在应用安装时<code>注册接收器</code>，然后，该接收器会成为应用的一个<code>独立入口点</code>，这意味着如果应用当前未运行，系统可以启动应用并发送广播</p>
</li>
<li>
<p>系统会创建新的 BroadcastReceiver 组件对象来处理它接收到的每个广播。此对象仅在调用 onReceive(Context, Intent) 期间有效。一旦从此方法返回代码，系统便会认为该组件不再活跃</p>
</li>
<li>
<p>要注册本地广播，请调用 <code>LocalBroadcastManager.registerReceiver(BroadcastReceiver, IntentFilter)</code></p>
</li>
<li>
<p><code>请注意注册和注销接收器的位置</code>，比方说，如果使用 Activity 上下文在 <code>onCreate(Bundle)</code> 中注册接收器，则应在 <code>onDestroy()</code> 中注销，以防接收器从 Activity 上下文中泄露出去。如果在 <code>onResume()</code>中注册接收器，则应在 <code>onPause()</code>中注销，以防多次注册接收器（如果您不想在暂停时接收广播，这样可以减少不必要的系统开销，<code>请勿在 onSaveInstanceState(Bundle) 中注销</code>，因为如果用户在历史记录堆栈中后退，则不会调用此方法。</p>
</li>
<li>
<p><code>广播消息封装在 Intent 对象中</code>。Intent 的操作字符串必须提供应用的 Java 软件包名称语法，并唯一标识广播事件。可以使用 putExtra(String, Bundle) 向 intent 附加其他信息。也可以对 intent 调用 <code>setPackage(String)</code>，将广播限定到同一组织中的一组应用。</p>
</li>
<li>
<p>如果不需要向应用以外的组件发送广播，则可以使用支持库中提供的 <code>LocalBroadcastManager</code>来收发本地广播。LocalBroadcastManager 效率更高（无需进行进程间通信），并且无需考虑其他应用在收发的广播时带来的任何安全问题。本地广播可在应用中作为通用的发布/订阅事件总线，而不会产生任何系统级广播开销</p>
</li>
<li>
<p>如果有许多应用在其清单中注册接收相同的广播，可能会导致系统启动大量应用，从而对设备性能和用户体验造成严重影响。为避免发生这种情况，请优先使用上下文注册而不是清单声明。有时，Android 系统本身会强制使用上下文注册的接收器。例如，CONNECTIVITY_ACTION 广播只会传送给上下文注册的接收器。</p>
</li>
<li>
<p><code>请勿使用隐式 intent 广播敏感信息</code>。任何注册接收广播的应用都可以读取这些信息。可以通过以下三种方式控制哪些应用可以接收您的广播：</p>
<ol>
<li>可以在发送广播时指定权限。</li>
<li>在 Android 4.0 及更高版本中，您可以在发送广播时使用 setPackage(String) 指定软件包。系统会将广播限定到与该软件包匹配的一组应用。</li>
<li>可以使用 LocalBroadcastManager 发送本地广播。</li>
</ol>
</li>
<li>
<p>当注册接收器时，任何应用都可以向您应用的接收器发送潜在的恶意广播。可以通过以下三种方式限制应用可以接收的广播：</p>
<ol>
<li>可以在注册广播接收器时指定权限。</li>
<li>对于清单声明的接收器，可以在清单中将 android:exported 属性设置为“false”。这样一来，接收器就不会接收来自应用外部的广播。</li>
<li>可以使用 LocalBroadcastManager 限制您的应用只接收本地广播。</li>
</ol>
</li>
<li>
<p>广播操作的命名空间是全局性的。请确保在自己的命名空间中编写操作名称和其他字符串，否则可能会无意中与其他应用发生冲突。</p>
</li>
<li>
<p>由于接收器的 onReceive(Context, Intent) 方法在<code>主线程</code>上运行，因此它会快速执行并返回。如果您需要执行长时间运行的工作，请谨慎生成线程或启动后台服务，因为系统可能会在 onReceive() 返回后终止整个进程。建议：</p>
<ol>
<li>在接收器的 <code>onReceive()</code>方法中调用 <code>goAsync()</code>，并将 BroadcastReceiver.PendingResult 传递给后台线程。这样，在从 onReceive() 返回后，广播仍可保持活跃状态。不过，<code>即使采用这种方法，系统仍希望您非常快速地完成广播（在 10 秒以内）</code>。为避免影响主线程，它允许您将工作移到另一个线程。</li>
<li>使用 <code>JobScheduler</code> 调度作业</li>
</ol>
</li>
<li>
<p>请勿从广播接收器启动 Activity，否则会影响用户体验，尤其是有多个接收器时。相反，可以考虑显示通知。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hilt 依赖注入框架]]></title>
        <id>https://wl-go.github.io/post/hilt-yi-lai-zhu-ru-kuang-jia/</id>
        <link href="https://wl-go.github.io/post/hilt-yi-lai-zhu-ru-kuang-jia/">
        </link>
        <updated>2020-12-31T01:20:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>依赖注入：<code>DI（Dependency Injection）</code> ，<code>Hilt</code>则是Android中的依赖注入框架</p>
</blockquote>
<p><a href="https://developer.android.google.cn/training/dependency-injection/hilt-android">官方文档</a></p>
<h1 id="具体用法">具体用法</h1>
<h2 id="添加依赖">添加依赖</h2>
<pre><code class="language-gradle">// 1. 项目build.gradle
dependencies {
    classpath 'com.google.dagger:hilt-android-gradle-plugin:2.28-alpha'
}

// 2. app/build.gradle
apply plugin: 'kotlin-kapt'
apply plugin: 'dagger.hilt.android.plugin'

dependencies {
    implementation &quot;com.google.dagger:hilt-android:2.28-alpha&quot;
    kapt &quot;com.google.dagger:hilt-android-compiler:2.28-alpha&quot;
}
</code></pre>
<h2 id="基本用法">基本用法</h2>
<h3 id="必须hiltandroidapp">必须（@HiltAndroidApp）</h3>
<p>自定义Application类，使用<code>@HiltAndroidApp</code> 注解该类，否则Hilt无法正常使用</p>
<blockquote>
<p><code>@HiltAndroidApp</code> 会触发 Hilt 的代码生成操作，生成的代码包括应用的一个基类，该基类充当应用级依赖项容器，生成的这一 Hilt 组件会附加到 <code>Application</code> 对象的生命周期，并为其提供依赖项，此外，它也是应用的父组件，这意味着，<code>其他组件可以访问它提供的依赖项</code>。</p>
</blockquote>
<pre><code class="language-kotlin">@HiltAndroidApp
class MyApp : Application() {
}
</code></pre>
<h3 id="6个注入入口点">6个注入入口点</h3>
<ul>
<li>Application</li>
<li>Activity</li>
<li>Fragment</li>
<li>View</li>
<li>Service</li>
<li>BroadcastReceiver</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>只有<code>Application入口点</code>使用<code>@HiltAndroidApp</code>，其余的都是使用<code>@AndroidEntryPoint</code>注解来声明的</li>
<li>使用 <code>@AndroidEntryPoint</code> 为某个 Android 类添加注释，则还必须为依赖于该类的 Android 类添加注释。<code>例如，如为某个 Fragment 添加注释，则还必须为使用该 Fragment 的所有 Activity 添加注释。</code></li>
<li><code>@AndroidEntryPoint</code> 会为项目中的每个 Android 类生成一个<code>单独的 Hilt 组件</code>。这些组件可以<strong>从它们各自的父类接收依赖项</strong>，<a href="https://developer.android.google.cn/training/dependency-injection/hilt-android#component-hierarchy"><strong><code>组件层次结构</code></strong></a></li>
</ol>
<p><strong>比如，Activity需要依赖注入</strong></p>
<pre><code class="language-kotlin">@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
}
</code></pre>
<h3 id="组件中声明依赖项inject">组件中声明依赖项（@Inject）</h3>
<blockquote>
<p>通过在组件中字段上添加<code>@Inject注解</code>，声明这个字段是个依赖项，需要通过依赖注入提供实例</p>
</blockquote>
<pre><code class="language-kotlin">@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    // 声明依赖项
    @Inject lateinit var a: A

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
}
</code></pre>
<h3 id="告知hilt如何提供依赖项">告知Hilt，如何提供依赖项</h3>
<h4 id="1-构造函数方式inject">1. 构造函数方式（@Inject）</h4>
<blockquote>
<p>通过在类的构造函数上添加<code>@Inject</code>注解，如果其构造函数中有依赖项，那么对应的类也需要告知Hilt如何提供实例</p>
</blockquote>
<pre><code class="language-kotlin">class A @Inject constructor() {
    fun doA() {
        println(&quot;AAAAA&quot;)
    }
}
</code></pre>
<h4 id="2-对接口的依赖注入">2. 对接口的依赖注入</h4>
<blockquote>
<p>接口是不可以通过构造函数的方式实现注入的，接口根本没有构造函数，这是时候需要 <code>@Module、@InstanllIn、@Qualifier、@Binds</code> ，同一类型不同实例的注入需要定义注解（用于区分）并且添加<code>@Qualifier</code></p>
</blockquote>
<p><strong>实例：</strong></p>
<ol>
<li>定义接口</li>
</ol>
<pre><code class="language-kotlin">interface IAction{
    fun doA()
    fun doB()
}
</code></pre>
<ol start="2">
<li>定义两个实现类（需要添加<code>@Inject</code>告诉<code>hilt</code>可以通过构造函数注入）</li>
</ol>
<pre><code class="language-kotlin">class A @Inject constructor(): IAction{
    override fun doA(){
        println(&quot;A - doA&quot;)
    }
    override fun doB(){
        println(&quot;A - doB&quot;)
    }
}

class B @Inject constructor(): IAction{
    override fun doA(){
        println(&quot;B - doA&quot;)
    }
    override fun doB(){
        println(&quot;B - doB&quot;)
    }
}
</code></pre>
<ol start="3">
<li>使用<code>@Qualifier</code>，创建注解（区分IAction类型，实现IAction的类存在多个）</li>
</ol>
<pre><code class="language-kotlin">@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class BindAIAction()

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class BindBIAction()
</code></pre>
<ol start="4">
<li>使用<code>@Module</code>、<code>@InstallIn</code>、<code>@Binds</code> 创建注入项模版</li>
</ol>
<pre><code class="language-kotlin">@Module
@InstallIn(ActivityComponent::class)
abstract class ActionModule {

    @BindAIAction
    @Binds
    abstract fun bindA(a: A): IAction

    @BindBIAction
    @Binds
    abstract fun bindB(b: B): IAction

    // 这里的 @BindAIAction，@BindBIAction主要就是区分，注入时的具体实现类是哪个
}
</code></pre>
<ol start="5">
<li>注入接口类型（这里也使用了自定义的注解，为了区分具体注入哪个实现类）</li>
</ol>
<pre><code class="language-kotlin">class Test{
    @BindAIAction // A
    @Inject
    lateinit var mA: IAction

    @@BindBIAction// B
    @Inject
    lateinit var mB: IAction
}
</code></pre>
<h4 id="3-第三方类的依赖注入">3. 第三方类的依赖注入</h4>
<blockquote>
<p>一般像三方库的类，比如<code>OkHttpClient</code>、<code>Retrofit</code>，需要使用<code>@Module、@InstanllIn、@Provides</code><br>
<strong>注意：这时使用<code>@Module</code>注解的不是抽象类了，而是一个普通的class，<code>@Provides</code>注解的是普通方法，需要有返回类型，这个返回类型就是需要提供的注入的实例</strong></p>
</blockquote>
<p><strong>实例</strong></p>
<pre><code class="language-kotlin">@Module
@InstallIn(ActivityComponent::class)
class httpModule{

    @Provides
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .build()
    }

    // 这里的OkHttpClient参数，就不需要定义了，因为上面已经有了
    @Provides
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .addConverterFactory(GsonConverterFactory.create())
            .baseUrl(&quot;http://127.0.0.1&quot;)
            .client(okHttpClient)
            .build()
    }
}
</code></pre>
<h2 id="hilt内置组件和组件作用域">Hilt内置组件和组件作用域</h2>
<h3 id="内置组件使用installin">内置组件使用（@InstallIn）</h3>
<blockquote>
<p><code>@InstallIn(hilt组件)</code><br>
比如：<code>ActivityComponent::class</code>，<code>@InstallIn(ActivityComponent::class)</code>，表示把这个模块安装到Activity组件当中，那么Activity、Activity中包含的Fragment和View也可以使用，其他地方无法使用</p>
</blockquote>
<h4 id="7种组件类型分别用于注入到不同的场景">7种组件类型，分别用于注入到不同的场景</h4>
<table>
<thead>
<tr>
<th>Hilt 组件</th>
<th>注入场景</th>
<th>作用域</th>
</tr>
</thead>
<tbody>
<tr>
<td>ApplictionComponent</td>
<td>Appliction</td>
<td>@Singleton</td>
</tr>
<tr>
<td>ActivityRetainedComponet</td>
<td>ViewModel</td>
<td>@ActivityRetainedScope</td>
</tr>
<tr>
<td>ActivityComponent</td>
<td>Activity</td>
<td>@ActivityScope</td>
</tr>
<tr>
<td>FragmentComponent</td>
<td>Fragment</td>
<td>@FragmentScope</td>
</tr>
<tr>
<td>ViewComponent</td>
<td>View</td>
<td>@ViewScope</td>
</tr>
<tr>
<td>ViewWithFragmentComponent</td>
<td>View annotated with @WithFragmentBindings</td>
<td>@ViewScope</td>
</tr>
<tr>
<td>ServiceComponent</td>
<td>Service</td>
<td>@ServiceScope</td>
</tr>
</tbody>
</table>
<h3 id="组件作用域">组件作用域</h3>
<ol>
<li>依上面表格，如果想要在<code>全程序范围内共用某个对象的实例</code>，那么就使用<code>@Singleton</code>。如果想要在某个<code>Activity</code>，以及它内部包含的<code>Fragment</code>和<code>View</code>中共用某个对象的实例，那么就使用<code>@ActivityScoped</code></li>
<li>没必要非得在Moudle中使用<code>作用域注解</code>，也可以直接在任何可注入类得上方使用</li>
</ol>
<pre><code class="language-kotlin">    @Singleton
    class A @Inject constructor() {
    }

    // 也可以
    @Module
    @InstallIn(ActivityComponent::class)
    abstract class ActionModule {
        @Singleton // 作用域
        @BindAIAction
        @Binds
        abstract fun bindA(a: A): IAction
    }
</code></pre>
<h2 id="预置qualifier-系统组件的注入">预置Qualifier （系统组件的注入）</h2>
<blockquote>
<p>专门就是用于给我们<code>提供Context类型</code>的依赖注入实例，对于某些依赖于Context类型的类，<code>@ApplicationContext</code>，<code>@ActivityContext</code></p>
</blockquote>
<h3 id="context-注入实例">Context 注入——实例</h3>
<pre><code class="language-kotlin">// ApplicationContext 全局的
@Singleton
class A @Inject constructor(@ApplicationContext val context: Context) {}

// 某个Activity 上下文
@ActivityScope
class B @Inject constructor(@ActivityContext val context: Context) {}
</code></pre>
<h3 id="application和activity-注入实例">Application和Activity 注入——实例</h3>
<blockquote>
<p><strong>注意必须是Application和Activity这两个类型，即使是声明它们的子类型，编译都无法通过</strong>，<code>**Hilt自动就能识别它们**</code></p>
</blockquote>
<pre><code class="language-kotlin">class A @Inject constructor(val application: Application) {
}

class B @Inject constructor(val activity: Activity) {
}
</code></pre>
<h2 id="转换hilt注入的appliction实例">转换Hilt注入的Appliction实例</h2>
<pre><code class="language-kotlin">@Module
@InstallIn(ApplicationComponent::class)
class ApplicationModule {

    @Provides
    fun provideMyApplication(application: Application): MyApplication {
        return application as MyApplication
    }
}
</code></pre>
<h2 id="viewmodel-依赖注入方式-viewmodelinject">ViewModel 依赖注入方式  @ViewModelInject</h2>
<h3 id="添加依赖appbuildgradle">添加依赖app/build.gradle</h3>
<pre><code class="language-gradle">dependencies {
    implementation 'androidx.hilt:hilt-lifecycle-viewmodel:1.0.0-alpha02'
    kapt 'androidx.hilt:hilt-compiler:1.0.0-alpha02'
}
</code></pre>
<h3 id="使用viewmodelinject">使用@ViewModelInject</h3>
<pre><code class="language-kotlin">class MainViewModel @ViewModelInject constructor(private val mainRepository: MainRepository) :
    ViewModel() {
}
</code></pre>
<p>使用@ViewModelInject，在MainViewModel上方就<code>不需要</code>添加组件作用域注解<code>@ActivityRetainedScoped</code>，其次，在获取ViewModel的方式还是使用<code>ViewModelProvider</code></p>
<pre><code class="language-kotlin">private val mainViewModel: MainViewModel by lazy {
    ViewModelProvider(this).get(MainViewModel::class.java)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin——作用域函数]]></title>
        <id>https://wl-go.github.io/post/kotlin-zuo-yong-yu-han-shu/</id>
        <link href="https://wl-go.github.io/post/kotlin-zuo-yong-yu-han-shu/">
        </link>
        <updated>2020-12-28T08:40:56.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>学习Kotlin官方文档的记录</p>
</blockquote>
<p><code>let</code>、<code>run</code>、<code>with</code>、<code>apply</code> 以及 <code>also</code></p>
<p><a href="let">let</a></p>
<p>这些函数的作用：<strong>在一个对象上执行一个代码块（<code>Lambda表达式</code>），不同的是这个对象在块中如何使用，以及整个表达式的结果是什么</strong></p>
<h1 id="let">let</h1>
<blockquote>
<p>上下文对象作为 lambda 表达式的<code>参数（it）</code>来访问。<font style='color:red'>返回值是<code>lambda 表达式的结果</code></font></p>
</blockquote>
<h2 id="在调用链的结果上调用一个或多个函数">在调用链的结果上调用一个或多个函数</h2>
<pre><code class="language-kotlin">val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;)
val resultList = numbers.map { it.length }.filter { it &gt; 3 }
println(resultList)
// 使用let简化，不需要resultList变量
// 若代码块仅包含以 it 作为参数的单个函数，则可以使用方法引用(::)代替 lambda 表达式
// ::println -&gt; println(it)
numbers.map { it.length }.filter { it &gt; 3 }.let{::println} 
</code></pre>
<h2 id="用于仅使用非空值执行代码块">用于仅使用非空值执行代码块</h2>
<blockquote>
<p>如需对非空对象执行操作，可对其使用安全调用操作符 <code>?.</code>并调用 <code>let</code> 在 lambda 表达式中执行操作</p>
</blockquote>
<pre><code class="language-kotlin">val str: String? = &quot;Hello&quot; 
val length = str?.let { 
    println(&quot;$it&quot;)
    it.length
}
</code></pre>
<h2 id="引入作用域受限的局部变量以提高代码的可读性">引入作用域受限的局部变量以提高代码的可读性</h2>
<blockquote>
<p>如需为上下文对象定义一个新变量，可提供其名称作为 lambda 表达式参数来替默认的 it</p>
</blockquote>
<pre><code class="language-kotlin">val numbers = listOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)
val modifiedFirstItem = numbers.first().let { firstItem -&gt;
    println(&quot;$firstItem&quot;)
    if (firstItem.length &gt;= 5) firstItem else &quot;!&quot; + firstItem + &quot;!&quot;
}.toUpperCase()
println(&quot;$modifiedFirstItem&quot;)
</code></pre>
<h1 id="with">with</h1>
<blockquote>
<p>一个非扩展函数：<code>上下文对象作为参数传递</code>，但是在 lambda 表达式内部，它可以作为<code>接收者（this）使用</code>。 <font style='color:red'>返回值是 lambda 表达式结果</font></p>
</blockquote>
<blockquote>
<p><em>建议使用 <code>with</code> 来调用上下文对象上的函数，而不使用 lambda 表达式结果。 在代码中，with 可以理解为<code>“对于这个对象，执行以下操作。”</code></em></p>
</blockquote>
<h2 id="对于这个对象执行以下操作">对于这个对象，执行以下操作</h2>
<pre><code class="language-kotlin">val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
with(numbers) {
    println(&quot;'with' is called with argument $this&quot;)
    println(&quot;It contains $size elements&quot;)
}
</code></pre>
<h2 id="引入一个辅助对象其属性或函数将用于计算一个值">引入一个辅助对象，其属性或函数将用于计算一个值</h2>
<pre><code class="language-kotlin">val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
val firstAndLast = with(numbers) {
    &quot;The first element is ${first()},&quot; +
    &quot; the last element is ${last()}&quot;
}
println(firstAndLast)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android常用Intent]]></title>
        <id>https://wl-go.github.io/post/android-chang-yong-intent/</id>
        <link href="https://wl-go.github.io/post/android-chang-yong-intent/">
        </link>
        <updated>2020-12-28T07:23:00.000Z</updated>
        <content type="html"><![CDATA[<p>记录有关常用<code>Intent</code>使用</p>
<p>⚠️注意：</p>
<ol>
<li>清单文件中添加需要的权限</li>
<li>有些<code>Intent</code>使用需要<code>动态权限申请</code></li>
<li>使用前，记得判断是否存在可处理Intent的对象，<code>intent.resolveActivity(packageManager) != null</code></li>
</ol>
<h1 id="拨打电话">拨打电话</h1>
<ol>
<li>
<p>添加权限<br>
<code>&lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot; /&gt;</code></p>
</li>
<li>
<p>Action</p>
<ul>
<li><code>Intent.ACTION_DIAL</code> - 打开拨号器或电话应用</li>
<li><code>Intent.ACTION_CALL</code> - 拨打电话（<strong>需要 CALL_PHONE 权限</strong>）<color style='color:red'>注意：直接把电话打出去了</color></li>
</ul>
</li>
<li>
<p>data数据URI</p>
<ul>
<li><code>tel:</code>电话号码</li>
<li><code>voicemail:</code>电话号码</li>
</ul>
</li>
<li>
<p>示例代码</p>
</li>
</ol>
<p><strong>4.1 直接拨号，需要动态权限</strong></p>
<pre><code class="language-kotlin">    // 直接拨号，需要动态权限
    private fun callPhone(){
        if (ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.CALL_PHONE
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            ActivityCompat.requestPermissions(
                this, arrayOf(Manifest.permission.CALL_PHONE), 101
            )
        } else {
            val callPhoneIntent = Intent(Intent.ACTION_CALL).apply {
                data = Uri.parse(&quot;tel:11111111111&quot;)
            }
            // 判断是否存在能处理此Intent的目标
            if (callPhoneIntent.resolveActivity(packageManager) != null) {
                startActivity(callPhoneIntent)
            } else {
                Toast.makeText(this, &quot;抱歉，此设备找不到拨号应用&quot;, Toast.LENGTH_SHORT).show()
            }
        }
    }

</code></pre>
<p><strong>4.2 去系统拨号界面</strong></p>
<pre><code class="language-kotlin">private fun goCallPhone(){
        val callPhoneIntent = Intent(Intent.ACTION_DIAL).apply {
            data = Uri.parse(&quot;tel:11111111111&quot;)
        }
        // 判断是否存在能处理此Intent的目标
        if (callPhoneIntent.resolveActivity(packageManager) != null) {
            startActivity(callPhoneIntent)
        } else {
            Toast.makeText(this, &quot;抱歉，此设备找不到拨号应用&quot;, Toast.LENGTH_SHORT).show()
        }
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android资源文件——Drawable状态列表资源]]></title>
        <id>https://wl-go.github.io/post/android-zi-yuan-wen-jian-drawable-zhuang-tai-lie-biao-zi-yuan/</id>
        <link href="https://wl-go.github.io/post/android-zi-yuan-wen-jian-drawable-zhuang-tai-lie-biao-zi-yuan/">
        </link>
        <updated>2020-12-28T07:12:28.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>StateListDrawable 是在 XML 文件中定义的可绘制对象，它会根据对象状态，使用多个不同的图像来表示同一个图形。<br>
例如，Button 可以是多种不同状态（按下、聚焦或这两种状态都不是）中的其中一种，并且您可利用状态列表可绘制对象，为每种状态提供不同的背景图片。<br>
在每个状态变更期间，将从上到下遍历状态列表，并使用第一个与当前状态匹配的项目。</p>
</blockquote>
<h1 id="文件位置">文件位置</h1>
<p><code>res/drawable/filename.xml</code></p>
<h1 id="编译后的资源数据类型">编译后的资源数据类型</h1>
<p><code>指向 StateListDrawable 的资源指针</code></p>
<h1 id="资源引用">资源引用</h1>
<ol>
<li>代码中：<code>R.drawable.filename</code></li>
<li>xml中：<code>@[package:]drawable/filename</code></li>
</ol>
<h1 id="语法">语法</h1>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:constantSize=[&quot;true&quot; | &quot;false&quot;]
    android:dither=[&quot;true&quot; | &quot;false&quot;]
    android:variablePadding=[&quot;true&quot; | &quot;false&quot;] &gt;
    &lt;item
        android:drawable=&quot;@[package:]drawable/drawable_resource&quot;
        android:state_pressed=[&quot;true&quot; | &quot;false&quot;]
        android:state_focused=[&quot;true&quot; | &quot;false&quot;]
        android:state_hovered=[&quot;true&quot; | &quot;false&quot;]
        android:state_selected=[&quot;true&quot; | &quot;false&quot;]
        android:state_checkable=[&quot;true&quot; | &quot;false&quot;]
        android:state_checked=[&quot;true&quot; | &quot;false&quot;]
        android:state_enabled=[&quot;true&quot; | &quot;false&quot;]
        android:state_activated=[&quot;true&quot; | &quot;false&quot;]
        android:state_window_focused=[&quot;true&quot; | &quot;false&quot;] /&gt;
&lt;/selector&gt;
</code></pre>
<h1 id="元素说明">元素说明</h1>
<table>
<thead>
<tr>
<th>元素名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>selector</td>
<td>根元素，里面包含一个或多个item</td>
</tr>
<tr>
<td>android:constantSize</td>
<td>布尔值。如果可绘制对象报告的内部大小在状态变更时保持不变，则值为“true”（大小是所有状态的最大值）</td>
</tr>
<tr>
<td>android:dither</td>
<td>布尔值。值为“true”时，将在位图的像素配置与屏幕不同时（例如：ARGB 8888 位图和 RGB 565 屏幕）启用位图的抖动</td>
</tr>
<tr>
<td>android:variablePadding</td>
<td>布尔值。如果可绘制对象的内边距应根据选择的当前状态而变化，则值为“true”</td>
</tr>
<tr>
<td>item</td>
<td>定义在某些状态下使用的drawable，状态通过其属性来描述</td>
</tr>
<tr>
<td><em>item 属性</em></td>
<td></td>
</tr>
<tr>
<td>android:drawable</td>
<td>可绘制对象资源</td>
</tr>
<tr>
<td>android:state_pressed</td>
<td>布尔值，在按下对象时（例如轻触/点按了按钮时）使用，则为“true”</td>
</tr>
<tr>
<td>android:state_focused</td>
<td>布尔值。如果此项应在聚焦对象时（例如使用轨迹球/方向键突出显示按钮时）使用，则为“true”</td>
</tr>
<tr>
<td>android:state_selected</td>
<td>布尔值。如果此项应在选择对象时（例如打开标签页时）使用，则为“true”</td>
</tr>
<tr>
<td>android:state_checkable</td>
<td>布尔值。如果此项应在对象可勾选时使用，则为“true”，仅适用于对象可在可勾选和不可勾选的微件之间转换的情况</td>
</tr>
<tr>
<td>android:state_checked</td>
<td>布尔值。如果此项应在勾选对象时使用，则为“true”</td>
</tr>
<tr>
<td>android:state_enabled</td>
<td>布尔值。如果此项应在启用对象（能够接收轻触/点按事件）时使用</td>
</tr>
<tr>
<td>android:state_window_focused</td>
<td>布尔值。如果此项应在应用窗口具有焦点（应用位于前台）时使用，则为“true”</td>
</tr>
<tr>
<td>android:state_hovered</td>
<td>布尔值。如果当光标悬停在对象上时应使用此项目，则值为“true”，此项为 API 级别 14 新引入的配置</td>
</tr>
<tr>
<td>android:state_activated</td>
<td>布尔值。如果在对象激活作为持续选择（例如，在持续导航视图中“突出显示”之前选中的列表项）时应使用此项目，则值为“true”</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android资源文件——颜色状态列表资源]]></title>
        <id>https://wl-go.github.io/post/android-zi-yuan-wen-jian-yan-se-zhuang-tai-lie-biao-zi-yuan/</id>
        <link href="https://wl-go.github.io/post/android-zi-yuan-wen-jian-yan-se-zhuang-tai-lie-biao-zi-yuan/">
        </link>
        <updated>2020-12-28T06:36:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>ColorStateList 是一个可以在 XML 中定义的对象，可以<code>将其作为颜色来使用</code>，但它实际上会更改颜色，具体取决于其应用到的View 对象的状态。例如，<code>Button可能处于多种不同状态中的一种（按下、聚焦或既不按下也不聚焦），而使用颜色状态列表，可以为每种状态提供不同的颜色。</code>在每次状态更改期间，系统将从上到下遍历状态列表，并且将使用与当前状态匹配的第一项。</p>
</blockquote>
<h1 id="文件位置">文件位置</h1>
<p><code>res/color/filename.xml</code></p>
<h1 id="编译后的资源数据类型">编译后的资源数据类型</h1>
<p><code>指向 ColorStateList 的资源指针</code></p>
<h1 id="资源引用">资源引用</h1>
<ol>
<li>代码中：<code>R.color.filename</code></li>
<li>xml中：<code>@[package:]color/filename</code></li>
</ol>
<h1 id="语法">语法</h1>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;
        &lt;item
            android:color=&quot;hex_color&quot;
            android:state_pressed=[&quot;true&quot; | &quot;false&quot;]
            android:state_focused=[&quot;true&quot; | &quot;false&quot;]
            android:state_selected=[&quot;true&quot; | &quot;false&quot;]
            android:state_checkable=[&quot;true&quot; | &quot;false&quot;]
            android:state_checked=[&quot;true&quot; | &quot;false&quot;]
            android:state_enabled=[&quot;true&quot; | &quot;false&quot;]
            android:state_window_focused=[&quot;true&quot; | &quot;false&quot;] /&gt;
    &lt;/selector&gt;
</code></pre>
<h1 id="元素说明">元素说明</h1>
<table>
<thead>
<tr>
<th>元素名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>selector</td>
<td>根元素，里面包含一个或多个item</td>
</tr>
<tr>
<td>item</td>
<td>定义在某些状态下使用的颜色，状态通过其属性来描述</td>
</tr>
<tr>
<td><em>item 属性</em></td>
<td></td>
</tr>
<tr>
<td>android:color</td>
<td>十六进制颜色</td>
</tr>
<tr>
<td>android:state_pressed</td>
<td>布尔值，在按下对象时（例如轻触/点按了按钮时）使用，则为“true”</td>
</tr>
<tr>
<td>android:state_focused</td>
<td>布尔值。如果此项应在聚焦对象时（例如使用轨迹球/方向键突出显示按钮时）使用，则为“true”</td>
</tr>
<tr>
<td>android:state_selected</td>
<td>布尔值。如果此项应在选择对象时（例如打开标签页时）使用，则为“true”</td>
</tr>
<tr>
<td>android:state_checkable</td>
<td>布尔值。如果此项应在对象可勾选时使用，则为“true”，仅适用于对象可在可勾选和不可勾选的微件之间转换的情况</td>
</tr>
<tr>
<td>android:state_checked</td>
<td>布尔值。如果此项应在勾选对象时使用，则为“true”</td>
</tr>
<tr>
<td>android:state_enabled</td>
<td>布尔值。如果此项应在启用对象（能够接收轻触/点按事件）时使用</td>
</tr>
<tr>
<td>android:state_window_focused</td>
<td>布尔值。如果此项应在应用窗口具有焦点（应用位于前台）时使用，则为“true”</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android开发规范手册]]></title>
        <id>https://wl-go.github.io/post/android-kai-fa-gui-fan-shou-ce/</id>
        <link href="https://wl-go.github.io/post/android-kai-fa-gui-fan-shou-ce/">
        </link>
        <updated>2020-12-28T05:14:41.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>学习《阿里巴巴Android开发手册》笔记</p>
</blockquote>
<h1 id="android资源文件命名">Android资源文件命名</h1>
<blockquote>
<p>小写单词+下划线的方式命名</p>
</blockquote>
<ol>
<li>
<p><strong>资源文件</strong>命名带上<strong>模块名称</strong></p>
</li>
<li>
<p><strong>layout文件</strong>的命名方式</p>
<ul>
<li>Activity 的 layout 以 <strong>module_activity</strong> 开头</li>
<li>Fragment 的 layout 以 <strong>module_fragment</strong> 开头</li>
<li>Dialog 的 layout 以 <strong>module_dialog</strong> 开头</li>
<li>include 的 layout 以 <strong>module_include</strong> 开头</li>
<li>ListView 的行 layout 以 <strong>module_list_item</strong> 开头</li>
<li>RecyclerView 的 item layout 以 <strong>module_recycle_item</strong> 开头</li>
<li>GridView 的行 layout 以 <strong>module_grid_item</strong> 开头</li>
</ul>
</li>
<li>
<p><strong>drawable 资源名称</strong></p>
</li>
</ol>
<blockquote>
<p>模块名_业务功能描述_控件描述_控件状态限定词<br>
<code>module_login_btn_pressed</code></p>
</blockquote>
<ol start="4">
<li><strong>anim 资源名称</strong></li>
</ol>
<blockquote>
<p>模块名_逻辑名称_[方向|序号]<br>
<code>tween 动画资源 ： 尽可能以通用的动画名称命名，如 module_fade_in ,module_fade_out ,module_push_down_in (动画+方向)；</code><br>
<code>frame 动画资源：尽可能以模 块+功能命名+序号。如：module_loading_grey_001</code></p>
</blockquote>
<ol start="5">
<li><strong>color 资源，module_colors.xml</strong></li>
</ol>
<blockquote>
<p>模块名_逻辑名称_颜色，#AARRGGBB 格式<br>
<code>&lt;color name=&quot;module_btn_bg_color&quot;&gt;#FF550055&lt;/color&gt;</code></p>
</blockquote>
<ol start="6">
<li><strong>dimen 资源，module_dimens.xml</strong></li>
</ol>
<blockquote>
<p>模块名_描述信息<br>
<code>&lt;dimen name=&quot;module_horizontal_line_height&quot;&gt;1dp&lt;/dimen&gt;</code></p>
</blockquote>
<ol start="7">
<li><strong>style 资源，module_styles.xml</strong></li>
</ol>
<blockquote>
<p>父 style 名称.当前 style 名称</p>
</blockquote>
<ol start="8">
<li><strong>string资源，module_strings.xml</strong></li>
</ol>
<blockquote>
<p>模块名_逻辑名称<br>
<code>moudule_login_tips,module_homepage_notice_desc</code></p>
</blockquote>
<ol start="9">
<li>** Id 资源缩写表**<br>
| 控件             | 缩写 |<br>
| ---------------- | ---- |<br>
| LinearLayout     | ll   |<br>
| RelativeLayout   | rl   |<br>
| ConstraintLayout | cl   |<br>
| ListView         | lv   |<br>
| ScollView        | sv   |<br>
| TextView         | tv   |<br>
| Button           | btn  |<br>
| ImageView        | iv   |<br>
| CheckBox         | cb   |<br>
| RadioButton      | rb   |<br>
| EditText         | et   |<br>
| <strong>其他控件</strong>         | ---    |<br>
| ProgressBar | progress_bar |<br>
| DatePicker | date_picker |</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[迭代器模式（Iterator）]]></title>
        <id>https://wl-go.github.io/post/die-dai-qi-mo-shi-iterator/</id>
        <link href="https://wl-go.github.io/post/die-dai-qi-mo-shi-iterator/">
        </link>
        <updated>2020-12-28T03:29:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote></blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文学摘要]]></title>
        <id>https://wl-go.github.io/post/wen-xue-zhai-yao/</id>
        <link href="https://wl-go.github.io/post/wen-xue-zhai-yao/">
        </link>
        <updated>2020-12-28T02:37:11.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>求知若渴，虚心若愚</p>
</li>
<li>
<p>原句：天才就是1%的灵感加上99%的汗水，但那1%的灵感是最重要的，甚至比那99%的汗水都要重要。——爱迪生</p>
</li>
<li>
<p>网络摘取</p>
</li>
</ul>
<pre><code>    知人不必言尽 留些口德

    责人不必苛尽 留些肚量

    锋芒不必露尽 留些深敛

    有功不必邀尽 留些谦让

    得理不必争尽 留些宽容

    富贵不必享尽 留些福泽
</code></pre>
<h2 id="白岩松白说">白岩松《白说》</h2>
<ul>
<li>面对现实说话，你的困扰是：树欲静而风不止。而你唯一能做出的选择是：无论风怎样动，树静。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android NDK 学习（上）]]></title>
        <id>https://wl-go.github.io/post/android-ndk-xue-xi-shang/</id>
        <link href="https://wl-go.github.io/post/android-ndk-xue-xi-shang/">
        </link>
        <updated>2020-12-24T08:49:05.000Z</updated>
        <content type="html"><![CDATA[<p>在这里主要记录的学习内容包括，JNI 概念、环境搭建、Native项目创建、CMake编译工具、ndk-build编译器工具<!-- more --></p>
]]></content>
    </entry>
</feed>